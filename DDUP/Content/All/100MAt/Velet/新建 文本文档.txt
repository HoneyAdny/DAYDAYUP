#version 450

layout(constant_id = 4) const uint _2 = 0u;
layout(constant_id = 2) const float _4 = 0.0;
layout(constant_id = 3) const float _5 = 0.0;
layout(constant_id = 1) const uint _6 = 0u;

struct _48
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
};

const vec2 _79[8] = vec2[](vec2(1.0), vec2(1.0), vec2(-1.0, 1.0), vec2(-1.0), vec2(1.0, -1.0), vec2(1.0), vec2(-1.0, 1.0), vec2(-1.0));
const float _1399[4] = float[](-0.01171875, 0.00390625, 0.01171875, -0.00390625);

layout(set = 1, binding = 1, std140) uniform _42_44
{
    vec4 _m0[5];
    vec4 _m1[5];
    vec4 _m2[1];
    vec4 _m3[5];
    vec4 _m4[4];
    vec4 _m5[8];
    vec4 _m6[8];
    vec4 _m7[1];
} _44;

layout(set = 0, binding = 0, std140) uniform _49_51
{
    vec4 _m0;
    uint _m1;
    uint _m2;
    int _m3;
    int _m4;
    ivec4 _m5;
    uvec4 _m6;
    _48 _m7;
} _51;

layout(set = 2, binding = 0) uniform samplerCube _13CubeMap;
layout(set = 2, binding = 1) uniform sampler2D _17花纹;
layout(set = 2, binding = 2) uniform sampler2D _18AO;
layout(set = 2, binding = 3) uniform sampler2D _19细节法线;
layout(set = 2, binding = 4) uniform sampler2D _20法线;
layout(set = 2, binding = 5) uniform sampler2D _21Depth;

layout(location = 0) in vec4 _23 切线;
layout(location = 1) in vec4 _24基向量法线;
layout(location = 5) in vec2 _27UV0;
layout(location = 6) in vec2 _28UV1;
layout(location = 7) in vec2 _29UV2;
layout(location = 2) in vec4 _30ColorRB;
layout(location = 3) in vec4 _31摄像机方向;
layout(location = 0) out vec4 _33;
vec4 _9;
float _1414;
uint _1418;
vec3 _1423 = vec3(255.0);

bool _55(bool _56)
{
    return !_56;
}

void main()
{
    vec3 _1419 = vec3(0.0);
    _9 = gl_FragCoord;//x 和 y 是屏幕空间坐标。 z 是深度值。w 是透视校正插值系数。
    vec2 _88 = ((gl_FragCoord.xy - (vec2(_4, _5) * 0.5)) * _79[_6]) + (vec2(_4, _5) * 0.5);
    _9 = vec4(_88.x, _88.y, _9.z, _9.w);//只变换了UV  深度没变 透视校正插值系数也没变
    vec3 _93 = _44._m6[2u].xyz;
    vec2 _100 = _44._m6[3u].xy;
    float _106 = _44._m6[4u].x;
    float _111 = _44._m6[5u].x;
    float _114 = _44._m6[6u].x;
    vec2 _117 = _44._m6[7u].xy;
    vec3 _122 = _44._m6[1u].xyz;
    float _126 = _44._m6[0u].x;
    float _129 = _44._m0[3u].x;
    vec3 _132 = _44._m0[2u].xyz;//(0.58,0.51,0.51)
    float _136 = _44._m0[0u].x;//感觉能控制亮度
    vec4 _140 = _9;
    _140.w = 1.0 / _9.w;//x 和 y 是屏幕空间坐标。 z 是深度值。w 是透视校正插值系数做了改变。
    bool _150 = gl_FrontFacing;
    bool _147 = _55(_150);
      //if (_147) 
    //{
    //discard; // 丢弃背面片段
    //}
    vec3 _160 = _23 切线.xyz;
    vec3 _159切线 = _160;
    vec4 _165 = _24基向量法线;
    vec4 _164法线基向量 = _165;
    vec3 _168副切线 = cross(_164法线基向量.xyz, _159切线) * _164法线基向量.www;
    vec4 _178 = _30ColorRB;
    vec4 _177ColorRB = _178;
    vec2 _183 = _44._m0[1u].xy;//0
    vec2 _202 = (((_9.xy + (-_183)) * _44._m1[4u].zw) + vec2(-0.5)) * vec2(2.0, -2.0);//UV 平移缩放 *负为翻转 坐标从屏幕空间转化为 NDC 
    vec3 _182;
    _182 = vec3(_202.x, _202.y, _182.z);
    _182.z = _9.z;
    vec4 _208;
    _208.w = 1.0;
    _208 = vec4(_182.x, _182.y, _182.z, _208.w);//用了新的UV 但是Z深度没变
    vec4 _181 = _208 * _140.wwww;
    vec3 _218归一负摄像机 = normalize(-_31摄像机方向.xyz);
    vec3 _217归一负摄像机 = _218归一负摄像机;
    float _224 = _136 * _44._m2[0u].w;//感觉能控制亮度
    int _230 = _147 ? 1 : (-1);//正反面
    vec2 _235Un法线 = (texture(_20法线, _27UV0).xy * vec2(2.0)) + vec2(-1.0);//解码法线XY
    vec4 _243;
    _243.w = 1.0;
    _243 = vec4(_235Un法线.x, _235Un法线.y, _243.z, _243.w);
    _243.z = sqrt(clamp(1.0 + (-dot(_235Un法线, _235Un法线)), 0.0, 1.0));
    float _257法线Z = _243.z + 1.0;
    vec2 _261Un细节法线xy = (texture(_19细节法线, _28UV1).xy * vec2(2.0)) + vec2(-1.0);
    vec4 _268;
    _268.w = 1.0;
    _268 = vec4(_261Un细节法线xy.x, _261Un细节法线xy.y, _268.z, _268.w);
    _268.z = sqrt(clamp(1.0 + (-dot(_261Un细节法线xy, _261Un细节法线xy)), 0.0, 1.0));
    vec3 _281 = mix(_268.xyz, vec3(0.0, 0.0, 1.0), _44._m5[5u].yyy);//lerp(A,B,-2);
    vec2 _289细节法线负XY = _281.xy * vec2(-1.0);
    vec3 _293最终法线;
    _293最终法线 = vec3(_235Un法线.x, _235Un法线.y, _293最终法线.z);
    _293最终法线.z = _257法线Z;
    vec3 _299最终细节法线;
    _299最终细节法线 = vec3(_289细节法线负XY.x, _289细节法线负XY.y, _299最终细节法线.z);
    _299最终细节法线.z = _281.z;
    vec3 _306最终法线;
    _306最终法线 = vec3(_235Un法线.x, _235Un法线.y, _306最终法线.z);
    _306最终法线.z = _257法线Z;
    vec3 _312最终细节法线;
    _312最终细节法线 = vec3(_289细节法线负XY.x, _289细节法线负XY.y, _312最终细节法线.z);
    _312最终细节法线.z = _281.z;
    vec3 _319合并法线 = (_306最终法线 * vec3(dot(_293最终法线, _299最终细节法线))) + (-(vec3(_257法线Z) * _312最终细节法线));
    vec3 _332最终法线WS = normalize((_164法线基向量.xyz * _319合并法线.zzz) + ((_168副切线 * _319合并法线.yyy) + (_159切线 * _319合并法线.xxx))) * vec3(_224 * float(_230));
    vec3 _355反射向量 = (-_217归一负摄像机) + ((_332最终法线WS * vec3(dot(_332最终法线WS, _217归一负摄像机))) * vec3(2.0));
    vec4 _367花纹 = texture(_17花纹, _29UV2);
    vec4 _371;
    _371 = vec4(_367花纹.xyz.x, _367花纹.xyz.y, _367花纹.xyz.z, _371.w);
    _371.w = _367花纹.w;
    vec4 _379花纹mask;
    _379花纹mask = vec4(_367花纹.xyz.x, _367花纹.xyz.y, _367花纹.xyz.z, _379花纹mask.w);
    _379花纹mask.w = _367花纹.w;
    vec4 _387花纹mask;
    _387花纹mask = vec4(_367花纹.xyz.x, _367花纹.xyz.y, _367花纹.xyz.z, _387花纹mask.w);
    _387花纹mask.w = _367花纹.w;
    float _395花纹RGB1 = mix(mix(_44._m5[6u].z, 1.0 + (-(1.0 + (-_44._m5[6u].z))), 1.0), _44._m5[6u].w, _387花纹mask.w);//lerp(1,0.4,花纹mask.w)
    vec4 _410最后花纹;
    _410最后花纹 = vec4(_367花纹.xyz.x, _367花纹.xyz.y, _367花纹.xyz.z, _410最后花纹.w);
    _410最后花纹.w = _367花纹.w;
    float _418花纹RGB2 = mix(_44._m5[7u].y, _44._m5[7u].x, _410最后花纹.w);//lerp（0.81，0，花纹的w）花纹是黑的
    vec3 _426花纹mask区分颜色 = max(mix(texture(_18AO, _27UV0).xyz * _44._m5[0u].xyz, _44._m5[1u].xyz * _367花纹.xyz, vec3(_371.w * _44._m5[5u].z)), vec3(0.0));//花纹mask区分颜色
    float _450花纹RGB3 = clamp(mix(_44._m5[6u].x, _44._m5[5u].w, _379花纹mask.w), 0.0, 1.0);//lerp(0.65,0.9,花纹mask.w)
    float _459花纹RGB = clamp(_395花纹RGB1, 0.119999997317790985107421875, 1.0);
    vec3 _463暗Color = _426花纹mask区分颜色 + (-(_426花纹mask区分颜色 * vec3(_450花纹RGB3)));//偏暗Color
    vec3 _158 = vec3(0.039999999105930328369140625 + (-(0.039999999105930328369140625 * _450花纹RGB3))) + (_426花纹mask区分颜色 * vec3(_450花纹RGB3));
    vec3 _157深色加RB = ((_463暗Color * _177ColorRB.xyz) * _132) * _44._m0[4u].zzz;//_44._m0[4u].zzz=1  _132=(0.58,0.51,0.51)
    float _156 = _177ColorRB.w * dot(_132, vec3(0.300000011920928955078125, 0.589999973773956298828125, 0.10999999940395355224609375));
    float _155 = 1.0;
    float _502 = _44._m3[1u].w;//7297.24
    float _501 7K = _502;//7297.24
    vec4 _507 = _44._m3[3u];//
    vec4 _506 = _507;//2048，1024，0.00049
    vec4 _154 = vec4(0.0);
    float _512 = _44._m3[4u].x;
    if (_181.w < _512)
    {
        _154 = _44._m4[3u] + ((_44._m4[2u] * _181.wwww) + ((_44._m4[1u] * _181.yyyy) + (_44._m4[0u] * _181.xxxx)));
    }
    if (_154.z > 0.0)
    {
        float _547 = 0.0;
        float _546 = min(_154.z, 0.999989986419677734375) + (-_547);
        vec2 _556 = (_154.xy * _506.xy) + vec2(-0.5);
        vec2 _563 = fract(_556);
        vec2 _566 = (floor(_556) + vec2(0.5)) * _506.zw;
        vec4 _574 = clamp(((textureGatherOffset(_21Depth, _566, ivec2(-2)) + (-vec4(_546))) * vec4(_501 7K)) + vec4(1.0), vec4(0.0), vec4(1.0));
        vec4 _592 = clamp(((textureGatherOffset(_21Depth, _566, ivec2(0, -2)) + (-vec4(_546))) * vec4(_501 7K)) + vec4(1.0), vec4(0.0), vec4(1.0));
        vec4 _606 = clamp(((textureGatherOffset(_21Depth, _566, ivec2(2, -2)) + (-vec4(_546))) * vec4(_501 7K)) + vec4(1.0), vec4(0.0), vec4(1.0));
        float _621 = (((((_574.w * (1.0 + (-_563.x))) + _574.z) + _592.w) + _592.z) + _606.w) + (_606.z * _563.x);
        vec2 _647;
        _647.x = _621;
        _647.y = (((((_574.x * (1.0 + (-_563.x))) + _574.y) + _592.x) + _592.y) + _606.x) + (_606.y * _563.x);
        float _555 = (_621 * (1.0 + (-_563.y))) + _647.y;
        vec4 _685 = clamp(((textureGatherOffset(_21Depth, _566, ivec2(-2, 0)) + (-vec4(_546))) * vec4(_501 7K)) + vec4(1.0), vec4(0.0), vec4(1.0));
        vec4 _699 = clamp(((textureGatherOffset(_21Depth, _566, ivec2(0)) + (-vec4(_546))) * vec4(_501 7K)) + vec4(1.0), vec4(0.0), vec4(1.0));
        vec4 _713 = clamp(((textureGatherOffset(_21Depth, _566, ivec2(2, 0)) + (-vec4(_546))) * vec4(_501 7K)) + vec4(1.0), vec4(0.0), vec4(1.0));
        float _727 = (((((_685.w * (1.0 + (-_563.x))) + _685.z) + _699.w) + _699.z) + _713.w) + (_713.z * _563.x);
        vec2 _753;
        _753.x = _727;
        _753.y = (((((_685.x * (1.0 + (-_563.x))) + _685.y) + _699.x) + _699.y) + _713.x) + (_713.y * _563.x);
        _555 += (_727 + _753.y);
        vec4 _788 = clamp(((textureGatherOffset(_21Depth, _566, ivec2(-2, 2)) + (-vec4(_546))) * vec4(_501 7K)) + vec4(1.0), vec4(0.0), vec4(1.0));
        vec4 _802 = clamp(((textureGatherOffset(_21Depth, _566, ivec2(0, 2)) + (-vec4(_546))) * vec4(_501 7K)) + vec4(1.0), vec4(0.0), vec4(1.0));
        vec4 _816 = clamp(((textureGatherOffset(_21Depth, _566, ivec2(2)) + (-vec4(_546))) * vec4(_501 7K)) + vec4(1.0), vec4(0.0), vec4(1.0));
        float _830 = (((((_788.w * (1.0 + (-_563.x))) + _788.z) + _802.w) + _802.z) + _816.w) + (_816.z * _563.x);
        vec2 _856;
        _856.x = _830;
        _856.y = (((((_788.x * (1.0 + (-_563.x))) + _788.y) + _802.x) + _802.y) + _816.x) + (_816.y * _563.x);
        float _885 = _555 + (_830 + (_856.y * _563.y));
        _555 = _885;
        float _896 = 0.039999999105930328369140625 * _885;
        _155 = min(_896, 1.0);
    }
    vec3 _901 = _157深色加RB * mix(_93, vec3(1.0), vec3(_155));
    vec3 _909HDir = normalize(_217归一负摄像机 + _44._m3[2u].xyz);//(0.88,0.214,0.423) 可能是   H
    float _916NoL = max(0.0, dot(_332最终法线WS, _44._m3[2u].xyz));//(0.88,0.214,0.423) NoL
    vec3 _923;
    _923.z = 0.0;
    _923 = vec3(_44._m5[4u].xy.x, _44._m5[4u].xy.y, _923.z);//(-0.98393,-0.17855,0)
    vec3 _930 = normalize(_923);
    vec3 _933 = normalize((_164法线基向量.xyz * _930.zzz) + ((_168副切线 * _930.yyy) + (_159切线 * _930.xxx)));
    vec3 _950NewR = normalize(_933 + (-(vec3(dot(_933, _332最终法线WS)) * _332最终法线WS)));//
    vec3 _961 = normalize(cross(_332最终法线WS, _950NewR));
    float _966 = dot(_909HDir, _217归一负摄像机);//VoH
    float _970 = dot(_217归一负摄像机, _332最终法线WS);
    vec3 _974 = (clamp(mix(_426花纹mask区分颜色, vec3(1.0), _44._m5[2u].yyy) * _44._m5[2u].xxx, vec3(0.0), vec3(1.0)) * vec3(pow(max(0.001000000047497451305389404296875, 1.0 + (-_970)), _44._m5[3u].x))) * _44._m5[3u].yyy;
        //                                                    00000               1                 0        1                                                                              4                       8
    float _999 = dot(_332最终法线WS, _909HDir);
    float _1003 = dot(_950NewR, _909HDir);
    float _1007 = dot(_961, _909HDir);
    float _1011 = abs(dot(_332最终法线WS, _217归一负摄像机));
    float _1016 = abs(dot(_332最终法线WS, _44._m3[2u].xyz));//(0.88,0.214,0.423)
    float _1023 = dot(_950NewR, _44._m3[2u].xyz);//(0.88,0.214,0.423)
    float _1029 = dot(_961, _44._m3[2u].xyz);
    float _1035 = _418花纹RGB2 * 0.9900000095367431640625;
    float _1039 = _459花纹RGB * _459花纹RGB;
    float _1043 = clamp(_1039 * (1.0 + _1035), 0.00999999977648258209228515625, 1.0);
    float _1050 = clamp(_1039 * (1.0 + (-_1035)), 0.00999999977648258209228515625, 1.0);
    vec3 _1057;
    _1057.x = _1043 * dot(_950NewR, _217归一负摄像机);
    _1057.y = _1050 * dot(_961, _217归一负摄像机);
    _1057.z = _1011;
    float _1072 = length(_1057);
    float _1075 = _1016 * _1072;
    vec3 _1079;
    _1079.x = _1043 * _1023;
    _1079.y = _1050 * _1029;
    _1079.z = _1016;
    float _1090 = length(_1079);
    float _1094 = _1043;//这个是什么意思
    float _1093 = _1094;
    float _1098 = _1050;
    float _1097 = _1098;
    float _1102 = _999;
    float _1101 = _1102;
    float _1106 = _1003;
    float _1105 = _1106;
    float _1110 = _1007;
    float _1109 = _1110;
    float _1113 = (((_1105 * _1105) / (_1093 * _1093)) + ((_1109 * _1109) / (_1097 * _1097))) + (_1101 * _1101);
    float _1134 = step(0.0, _1101) / (((_1093 * _1097) * _1113) * _1113);
    float _1133 = min(_44._m5[6u].y, ((((2.0 * _1011) * _1016) * (1.0 / max(_1075 + (_1011 * _1090), 9.9999997473787516355514526367188e-05))) * _1134) / max((4.0 * _1016) * _1011, 9.9999997473787516355514526367188e-05));
    float _1170 = (_44._m5[4u].z * 0.017453290522098541259765625) * clamp((_1133 * _1133) * 0.25, 0.0, 1.0);
    float _1182 = cos(_1170);
    vec3 _1185 = ((vec3(_1182) * _158) + (vec3(sin(_1170)) * cross(vec3(0.57735002040863037109375), _158))) + ((vec3(dot(vec3(0.57735002040863037109375), _158)) * vec3(0.57735002040863037109375)) * vec3(1.0 + (-_1182)));
    float _1210 = 1.0 + (-_966);
    float _1214 = _1210 * _1210;
    float _1209 = (_1214 * _1214) * _1210;
    vec3 _1223 = (vec3(clamp(50.0 * _1185.y, 0.0, 1.0) * _1209) + (vec3(1.0 + (-_1209)) * _1185)) * vec3(_1133);
    vec3 _1244 = _44._m1[2u].xyz;
    vec3 _1248 = _44._m1[1u].xyz;
    vec3 _1252 = _44._m1[0u].xyz;
    vec3 _1243 = (_1244 * _164法线基向量.zzz) + ((_1248 * _164法线基向量.yyy) + (_1252 * _164法线基向量.xxx));
    vec3 _1242 = _1243;
    float _1271 = length(_1243.xy);
    vec2 _1280 = _1243.xy / vec2(_1271 + 0.001000000047497451305389404296875);
    _1242 = vec3(_1280.x, _1280.y, _1242.z);
    float _1284 = (_129 + (-1.0)) + (-(1.0 + (-(1.2000000476837158203125 * log2(clamp(clamp(_395花纹RGB1, 0.0, 1.0), 9.9999999747524270787835121154785e-07, 1.0))))));
    vec4 _1283 = textureLod(_13CubeMap, _355反射向量, _1284);
    vec3 _1302 = _1283.xyz * vec3(_1283.w * 16.0);
    float _1311 = _44._m7[0u].x;
    vec3 _1378 = min(vec3(200.0), (((_901 + ((vec3(_155 * _916NoL) * _44._m3[0u].xyz) * ((_463暗Color + _974) + _1223))) + (vec3(((smoothstep(_100.x, _100.y, (dot(_117, _1242.xy) + (-_111)) * _106) * _44._m5[3u].w) * pow(1.0 + (-clamp(_970, 0.0, 1.0)), _114)) * _126) * _122)) + ((((_1302 * _1302) * vec3(_1311)) * vec3(_156)) * _158)) + mix(vec3(0.0), vec3(0.0), vec3(_155)));
    //                              深色                   NoL    (0.89,0.84,0.9)   
    vec4 _153;
    _153 = vec4(_1378.x, _1378.y, _1378.z, _153.w);
    _153.w = 0.0;
    float _1382 = min(_31摄像机方向.w, 65504.0);
    _153.w = _1382;
    _33 = _153;
    if (_2 != 0u)
    {
        _1414 = _1399[((uint(gl_FragCoord.x) & 1u) << 1u) | (uint(gl_FragCoord.y) & 1u)];
        _1418 = (_2 >> 0u) & 3u;
        switch (_1418)
        {
            case 1u:
            {
                _1419 = vec3(_1414 * 2.0);
                _1423 = vec3(15.0);
                break;
            }
            case 2u:
            {
                _1419 = vec3(_1414);
                _1423 = vec3(31.0);
                break;
            }
            case 3u:
            {
                _1419 = vec3(_1414, _1414 * 0.5, _1414);
                _1423 = vec3(31.0, 63.0, 31.0);
                break;
            }
        }
        vec3 _1448 = _33.xyz + _1419;
        _33 = vec4(_1448.x, _1448.y, _1448.z, _33.w);
        vec3 _1457 = round(_33.xyz * _1423) / _1423;
        _33 = vec4(_1457.x, _1457.y, _1457.z, _33.w);
    }
}

